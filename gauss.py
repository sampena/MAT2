# -*- coding: utf-8 -*-
"""Gauss.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P6u5YT3xQkSqn7sDg5p5kINCZU7f5-0i

# Gauss-Jordan
Eliminación gaussiana con pivoteo
"""

#Relaciones
import numpy as np

def GaussJordan(A, b):
    '''
    Basado en el proyecto https://gist.github.com/num3ric/1357315 de Éric Renaud-Houde 
    Eliminación gaussiana con pivoteo.
#     % Parámetros: 
#     %  A: matrix de los coeficientes del sistema de ecuaciones lineales de n x n  
#     %  b: Vector de n x 1 complemento a la matriz ampliada 
#     % Salida: x Solución of Ax=b.
#     % post-condition: A y b fueron modificados. 
    '''
    #Obtención de la dimensión de la matriz
    n =  len(A)
    
    # Validación de correspondencia entre A y b
    if b.size != n:
        raise ValueError("Argumento inválido: tamaños incompatibles entre matriz A & vector b.", b.size, n)
    # k represents the current pivot row. Since GE traverses the matrix in the upper 
    # right triangle, we also use k for indicating the k-th diagonal column index.
    for k in range(n-1):
        #Choose largest pivot element below (and including) k
        maxindex = abs(A[k:,k]).argmax() + k
        if A[maxindex, k] == 0:
            raise ValueError("Matrix is singular.")
        #Swap rows
        if maxindex != k:
            A[[k,maxindex]] = A[[maxindex, k]]
            b[[k,maxindex]] = b[[maxindex, k]]
        for row in range(k+1, n):
            multiplier = A[row][k]/A[k][k]
            #the only one in this column since the rest are zero
            A[row][k] = multiplier
            for col in range(k + 1, n):
                A[row][col] = A[row][col] - multiplier*A[k][col]
            #Equation solution column
            b[row] = b[row] - multiplier*b[k]
    
    #print (A)
    #print (b)
    x = np.zeros(n)
    k = n-1
    x[k] = b[k]/A[k,k]
    while k >= 0:
        x[k] = (b[k] - np.dot(A[k,k+1:],x[k+1:]))/A[k,k]
        k = k-1
    return x
